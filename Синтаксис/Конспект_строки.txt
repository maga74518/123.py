Метод ljust:

d = 'qwerty'
print(d.ljust(10, '!@'))
print(d.ljust(10, ''))

принимает один обязательный параметр width - ширину строки и один необязательный параметр fillchar - знак
заполнителя (по умолчанию пробел) . Возвращает новую строку, в которой исходная строка S дополнена справа символами
fillchar до указанной длины width.
Если параметр width меньше длины строки, то будет возвращена исходная строка без изменений:


Метод .rjust:

d = 'qwerty'
print(d.rjust(10))
print(d.rjust(10, '-'))
print(d.rjust(10, '&'))
print(d.rjust(5, '!'))

принимает один обязательный параметр width - ширину строки и один необязательный параметр fillchar - знак
заполнителя (по умолчанию пробел) . Возвращает новую строку, в которой исходная строка S дополнена слева символами
 fillchar до указанной длины width. Если параметр width меньше длины строки, то будет возвращена исходная строка без изменений:


Метод .center:

принимает один обязательный параметр width - ширину строки и один необязательный параметр fillchar - знак
заполнителя (по умолчанию пробел) . Возвращает новую строку длины width, в которой исходная строка S находится в центре,
а справа и слева от нее находятся символы fillchar . Если параметр width меньше длины строки, то будет возвращена
исходная строка без изменений.

d = 'qwerty'
print(d.center(10))
print(d.center(12, '!'))
print(d.center(13, '?'))
print(d.center(5, '!')


Метод .zfill:
Возвращает новую строку, в которой исходная строка S дополнена нулями слева так, чтобы длина новой строки стала равна width.

d = '123'
print(d.zfill(5))
print(d.zfill(6))
print(d.zfill(2))
print(d.zfill(3))
c



Метод  .strip:
возвращает копию строки, удаляя как начальные, так и конечные символы (в зависимости от переданного строкового аргумента).
 Метод удаляет символы как слева, так и справа в зависимости от аргумента chars . Если аргумент chars не передан, то по
  умолчанию удаляться пробелы и символы переноса на новую строку \n

q = '   hello   '
print(q)
print(q.strip())
print('\n\n\n_USB_\n\n\n\n'.strip())
print('123_USB_123'.strip('123'))

(rstrip == удаляет все знаки справа а lstrip == слева)



                                        !!!!!F'{Строки}!!!!!


Ответ простой - форматировать. F-строки поддерживают функционал форматирования. Мы указываем специальным образом после
имени переменной сколько символов ожидаем увидеть.

a = 1/8
b = 1/2
c = 1/3
print(f'{a = :.3f}')
print(f'{b = :.3f}')
print(f'{c = :.3f}')
print('------')
print(f'{c:.3f}')
print(f'{c:.1f}')
print(f'{c:.2f}')
print(f'{c:.10f}')

Можно также влиять на знак разделителя между группами чисел, посмотрите пример ниже:

n = 12345678912345

print(f'{n:,d}') == #12,345,678,912,345
print(f'{n:_d}') == #12_345_678_912_345

sep = '_'
print(f'{n:{sep}d}') # вложенная f-строка == #12_345_678_912_345

Выравнивание по левой стороне:

n = 12345
print(f'{n:08d}') ==     #00012345
print(f'{n:07d}') ==     #0012345
print(f'{n:06d}') ==     #012345

Самый простой способ вернуть в двоичном виде без лишних цифр 0b как в функции bin
Это через f строку или функцию format() int(f'{self:b}')


                                     !!! endswift !!!

Метод endswith() в Python используется для проверки, заканчивается ли строка определенной подстрокой.

Метод endswith() возвращает True, если строка заканчивается указанной подстрокой, и False в противном случае. Например,
если мы хотим проверить, заканчивается ли строка my_string подстрокой world, мы можем использовать следующий код:

